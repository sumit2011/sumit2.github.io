[{"categories":null,"content":"About me","date":"2023-01-07","objectID":"/about/","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Hii, my name is Sumit Kumar, i am currently pursuing B.Tech at NIT Srinagar. I’m interested in cybersecurity and competitive programming and love to solve problems. I’m also a part of z3r0d4y(a cybersecurity club at NIT Srinagar). I have the following qualities: I’m curious to learn new things. I’m extremely loyal to my family and friends. Resume ","date":"2023-01-07","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Skills ","date":"2023-01-07","objectID":"/about/:1:0","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Cybersecurity To be honest I’m just a beginner at this stage and interested to learn all about hacking. I’m currently learning hacking from the following platforms. Platform: THM , HTB , Hacker-X. THM Certificates THM Badges THM Pwned Machines Hacker-X Certificates Tools ","date":"2023-01-07","objectID":"/about/:1:1","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"Programming I’m also learning Data Structure and Algorithm, C++, C, Python. Platform: codechef, coding ninja. Languages ","date":"2023-01-07","objectID":"/about/:1:2","tags":null,"title":"About me","uri":"/about/"},{"categories":["Cyber Security"],"content":"Here i will help you in your jr penetration tester pathway on THM. ","date":"2023-01-05","objectID":"/jr-penetration-tester/:0:0","tags":["C"],"title":"THM Jr Penetration Tester Pathway Guide","uri":"/jr-penetration-tester/"},{"categories":["Cyber Security"],"content":"Introduction to Cyber Security ","date":"2023-01-05","objectID":"/jr-penetration-tester/:1:0","tags":["C"],"title":"THM Jr Penetration Tester Pathway Guide","uri":"/jr-penetration-tester/"},{"categories":["Cyber Security"],"content":"Intro to Offensive Security Hacking your first machine Q1. When you’ve transferred money to your account, go back to your bank account page. What is the answer shown on your bank balance page? Ans-BANK-HACKED Q2. If you were a penetration tester or security consultant, this is an exercise you’d perform for companies to test for vulnerabilities in their web applications; find hidden pages to investigate for vulnerabilities. No Answer Needed Q3. Terminate the machine by clicking the red “Terminate” button at the top of the page. No Answer Needed ","date":"2023-01-05","objectID":"/jr-penetration-tester/:1:1","tags":["C"],"title":"THM Jr Penetration Tester Pathway Guide","uri":"/jr-penetration-tester/"},{"categories":["DSA"],"content":"Navigation system works on the concept of linked list. Note Use the table of contents to navigate to the portion that you are interested in. ","date":"2022-12-26","objectID":"/single_linked_list/:0:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"1. Introduction: Single linked list is a linear data structure. It’s elements are not stored in contiguous memory location like arrays. it is slightly different from array. it made by the nodes, each nodes consist a data and the address of the next node and each nodes are linked using pointers. ","date":"2022-12-26","objectID":"/single_linked_list/:1:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"2. Creation of Node To create a new node in C++, you will need to define a structure or class that represents a node, and then create an instance of that structure or class. Here is an example of a node structure in C++: struct Node { int value; Node* next; }; ","date":"2022-12-26","objectID":"/single_linked_list/:2:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"3. Insertion An insertion operation in a single linked list involves adding a new node to the list. There are several ways to do this, depending on where you want to insert the new node: At the beginning of the list At the end of the list At a specific position ","date":"2022-12-26","objectID":"/single_linked_list/:3:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"3.1 Insertion at Begining To insert a new node at the beginning of the list, you need to create a new node and set its next pointer to point to the current head of the list. Then, you can set the head of the list to the new node. void insertAtBeg(int value) { struct Node *newnode; newnode = (struct Node *)malloc(sizeof(struct Node)); newnode-\u003edata = value; if (head == NULL) { newnode-\u003enext = NULL; head = newnode; } else { newnode-\u003enext = head; head = newnode; } printf(\"\\n\\n*Inserted successfully at beginning*\\n\"); } ","date":"2022-12-26","objectID":"/single_linked_list/:3:1","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"3.2 Insertion at Last To insert a new node at the end of the list, you need to traverse the list until you reach the last node. Then, you can set the next pointer of the last node to point to the new node. void insertATend(int value) { struct Node *newnode; newnode = (struct Node *)malloc(sizeof(struct Node)); newnode-\u003edata = value; if (head == NULL) { newnode-\u003enext = NULL; head = newnode; } else { struct Node *temp; temp = head; while (temp-\u003enext != NULL) { temp = temp-\u003enext; } temp-\u003enext = newnode; newnode-\u003enext = NULL; } printf(\"\\n\\n*Inserted Successfully in END *\\n\"); } ","date":"2022-12-26","objectID":"/single_linked_list/:3:2","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"3.3 Insertion at Any Position To insert a new node at a specific position in the list, you need to traverse the list until you reach the node before the position where you want to insert the new node. Then, you can set the next pointer of the new node to point to the node at the desired position, and set the next pointer of the node before the position to point to the new node. // insertion at any position void insertAtPos(int pos, int value) { struct Node *newnode; newnode = (struct Node *)malloc(sizeof(struct Node)); newnode-\u003edata = value; struct Node *temp = NULL; int i = 1; temp = head; while (i \u003c pos - 1) { temp = temp-\u003enext; i++; } newnode-\u003enext = temp-\u003enext; temp-\u003enext = newnode; } ","date":"2022-12-26","objectID":"/single_linked_list/:3:3","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"4. Deletion A deletion operation in a single linked list involves removing a node from the list. There are several ways to do this, depending on which node you want to delete: Deleting the head node Deleting the last node Deleting a node in the middle of the list ","date":"2022-12-26","objectID":"/single_linked_list/:4:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"4.1 Deletion from Begining To delete the head node, you simply need to set the head of the list to the next node in the list. // deletion at begining void deletatBeg() { struct Node *temp; temp = head; head = head-\u003enext; free(temp); } ","date":"2022-12-26","objectID":"/single_linked_list/:4:1","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"4.2 Deletion from End To delete the last node, you need to traverse the list until you reach the second-to-last node. Then, you can set the next pointer of the second-to-last node to null, effectively removing the last node from the list. // deletion at end void deletatEnd() { struct Node *temp, *prev; prev = temp = head; while (temp-\u003enext != NULL) { prev = temp; temp = temp-\u003enext; } prev-\u003enext = NULL; free(temp); } ","date":"2022-12-26","objectID":"/single_linked_list/:4:2","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"4.3 Deletion from Any Position To delete a node in the middle of the list, you need to traverse the list until you reach the node before the one you want to delete. Then, you can set the next pointer of the previous node to point to the node after the one you want to delete, effectively skipping over the node to be deleted. // deletion at any position void deletatPos(int pos) { struct Node *nextnode, *temp; int i = 1; nextnode = temp = head; while (i \u003c pos) { temp = nextnode; nextnode = nextnode-\u003enext; i++; } temp-\u003enext = nextnode-\u003enext; free(nextnode); } ","date":"2022-12-26","objectID":"/single_linked_list/:4:3","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"5. Sorting of the Single Linked List There are several ways to sort a single linked list, depending on the type of data being stored in the list and the desired sort order. Here are a few common approaches: Bubble sort: This is a simple sorting algorithm that repeatedly iterates through the list, compares adjacent nodes, and swaps their values if they are in the wrong order. It continues this process until the list is sorted. Merge sort: This is a divide-and-conquer algorithm that recursively splits the list in half, sorts each half, and then merges the two sorted halves back together. It is generally more efficient than bubble sort, but requires additional memory to store the sublists during the recursive splits. Quick sort: This is another divide-and-conquer algorithm that selects a “pivot” element from the list and reorders the list so that all elements less than the pivot come before it and all elements greater than the pivot come after it. It then repeats this process recursively on the sublists on either side of the pivot until the list is sorted. Quick sort is generally faster than merge sort, but its performance can degrade if the pivot is not well-chosen. // sorting of linked list void sortlist() { struct Node *ptr, *cpt; ptr = head; int temp; while (ptr-\u003enext != NULL) { cpt = ptr-\u003enext; while (cpt != NULL) { if (ptr-\u003edata \u003e cpt-\u003edata) { temp = ptr-\u003edata; ptr-\u003edata = cpt-\u003edata; cpt-\u003edata = temp; } cpt = cpt-\u003enext; } ptr = ptr-\u003enext; } } ","date":"2022-12-26","objectID":"/single_linked_list/:5:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"6. Print Function // printing of linked list void print() { struct Node *temp; temp = head; while (temp != NULL) { printf(\"%d--\u003e\", temp-\u003edata); temp = temp-\u003enext; } printf(\"NULL\"); } ","date":"2022-12-26","objectID":"/single_linked_list/:6:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"7. To Find Length // length of the linked int getlength() { int len = 0; struct Node *temp = head; while (temp != NULL) { len++; temp = temp-\u003enext; } printf(\"%d\", len); } ","date":"2022-12-26","objectID":"/single_linked_list/:7:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"},{"categories":["DSA"],"content":"8. Main Function // main function int main() { // int a; // printf(\"how many elements do you want enter= \"); // scanf(\"%d\", \u0026a); // for (int i = 0; i \u003c a; i++) // { // int data; // scanf(\"%d\", \u0026data); // insertATend(data); // } // print(); insertAtBeg(34); insertAtBeg(45); insertAtBeg(72); insertAtBeg(5); insertAtBeg(89); insertAtBeg(99); insertATend(23); insertATend(55); insertATend(13); insertATend(41); insertAtPos(6, 8992); print(); printf(\"\\n\"); deletatBeg(); deletatEnd(); deletatPos(3); print(); printf(\"\\n\"); sortlist(); print(); insertATend(58); print(); printf(\"\\n\"); reverse(); print(); printf(\"\\n\\n\"); printf(\"length: \"); getlength(); return 0; } ","date":"2022-12-26","objectID":"/single_linked_list/:8:0","tags":["C","C++"],"title":"Single Linked List","uri":"/single_linked_list/"}]